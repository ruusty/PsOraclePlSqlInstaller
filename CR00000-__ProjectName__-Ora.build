<?xml version="1.0" encoding="utf-8" ?>
<project name="CR00000-__ProjectName__-Ora" default="build">
    <description>Build file for the CR00000-__ProjectName__ using Git</description>

    <!--=============================================================================
      Copyright : Ched Services P/L

        Project : GIS OMS

    Applic Name : CR00000-__ProjectName__

         Author : Russell

           Date : __localdate__

    ============================================================================== -->
<script language="C#" prefix="FileUtil">
    <references>
            <include name="System.dll" />
    </references>
    <code>
        <![CDATA[
        //Find the filename in the current working directory (cwd) and upwards
        [Function("FindFileUp")]
            public static String FindFileUp(string cwd, string fileName)
        {
            string startPath = Path.Combine(Path.GetFullPath(cwd), fileName);
            FileInfo file = new FileInfo(startPath);
            while (!file.Exists) {
                if (file.Directory.Parent == null) {
                    return null;
                }
                DirectoryInfo parentDir = file.Directory.Parent;
                file = new FileInfo(Path.Combine(parentDir.FullName, file.Name));
            }
            return file.FullName;
        }

]]>
    </code>
</script>
    <script language="C#" prefix="version">
        <references>
                <include name="System.dll" />
        </references>
        <code>
            <![CDATA[
    [Function("plsql")]
    public static string RegexVersionPlSql(string pFileName, string pVersion )
    {
       string s = "";     //Line containg the version: gr_VERSION constant VARCHAR2(200) := '4.3.0.0';
       using (System.IO.StreamReader sr = new System.IO.StreamReader(pFileName))
       {
          s = @sr.ReadToEnd();
       }
       System.Text.RegularExpressions.RegexOptions   options = (System.Text.RegularExpressions.RegexOptions.Multiline|System.Text.RegularExpressions.RegexOptions.IgnoreCase);
       System.Text.RegularExpressions.Regex          re = new System.Text.RegularExpressions.Regex(@"(?<versionProlog>^\s*gr_VERSION\s+CONSTANT\s+VARCHAR2\(\d{3,}\)\s*:=\s*')(?<verionsNum>[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)(?<versionSuffix>'\s*;)", options);
       string         replacement = String.Format("${{versionProlog}}{0}${{versionSuffix}}",pVersion);
       s = re.Replace(@s, replacement);
       using (System.IO.StreamWriter sw = new System.IO.StreamWriter(pFileName, false, System.Text.Encoding.ASCII))
       {
          sw.Write(s);
       }
       return (replacement);
    }
]]>
        </code>

    </script>

    <property name="proj.build.name" value="${path::get-file-name-without-extension(project::get-name() )}"/>
    <!-- Get the current working directory of the build file.  We'll use this to root every thing relative to this -->
    <property name="proj.topdir" value="${path::get-directory-name(project::get-buildfile-path())}"/>
    <property name="GisOms.properties.filename" value="GisOms.Chocolatey.properties.${environment::get-machine-name()}.xml"/>
    <echo message="Config:${GisOms.properties.filename}"/>
    <property name="GisOms.properties.path" value="${FileUtil::FindFileUp(proj.topdir,GisOms.properties.filename)}"/>
    <if test="${GisOms.properties.path == ''}" >
        <fail message="${GisOms.properties.filename} not found"/>
    </if>
    <include buildfile="${GisOms.properties.path}" unless="${property::exists('props.included')}"/>

    <!-- Project config settings {-->        <!-- INSTRUCTION: Change these variable  -->
    <property name="proj.choco.dir"          value="${path::combine(proj.topdir,'..\..\src\ched-' + project::get-name())}"/>                      <!-- Chocolatey location -->
    <property name="proj.choco.nant.build"   value="${path::combine(proj.choco.dir,'ched-' + project::get-name() + '-Choco.build')}"/>            <!-- Chocolatey build location -->
    <property name="proj.Dist.Dir"           value="Dist"   />                                                            <!-- Dist location under ${proj.topdir} -->
    <property name="proj.dist.path"          value="${path::combine(proj.topdir,proj.Dist.Dir)}"   />                     <!-- Dist location absolute path under ${proj.topdir} -->
    <property name="proj.Build.Dir"          value="Build"   />                                                           <!-- Build location under ${proj.topdir} -->
    <property name="proj.Build.path"         value="${path::combine(proj.topdir,proj.Build.Dir)}"   />                    <!-- Build location absolute path under ${proj.topdir} -->
    <property name="package.zipFname"        value="${path::combine (proj.dist.path,proj.build.name+'.zip')}" />
    <property name="package.ListFname"       value="${path::combine (proj.topdir,proj.build.name+'.lis')}" />

    <property name="proj.history"            value="${proj.build.name}.history.log" />
    <property name="proj.version.file"       value="${proj.build.name}.Build.Number" />

    <!-- Project config settings }-->

    <target name="test-build" depends="clean,git-history,set-version,compile" description="Does the non-destructive build">
        <echo message="Building ${proj.build.name}" />
    </target>

    <target name="build" depends="git-status,clean,git-history,set-version,tag,compile,distribute,show-deliverable" description="Does the full build and copies the deliverable to \\COVMWNECODP1\Delivery\CR33194-PlannedOutageNotifConnCustomer">
        <echo message="Building ${proj.build.name}" />
    </target>

     <target name="compile" description="Build Deliverable" depends="set-version">
         <loadfile file="${proj.version.file}"     property="AppBuildNumber.version" />
         <property name="local.PackageVersion"     value="${AppBuildNumber.version}"/>

        <copy todir="${proj.Build.Dir}" flatten="false" verbose="true">
            <fileset basedir="${proj.topdir}">  <!-- INSTRUCTION: Files specification to build directory  -->
                 <include name="**/*" />
                 <exclude name="990_Version-pon.oms.sql" />
                 <exclude name="**/*.log" />
                 <exclude name="**/*.zip" />
                 <exclude name="**/*.credential" />
                 <exclude name="**/.*" />
                 <exclude name="Dist/**/*" />
                 <exclude name="Build/**/*" />
                 <exclude name="Dist" />
                 <exclude name="Build" />
            </fileset>
        </copy>

        <copy todir="${proj.Build.Dir}" verbose="true">
           <fileset basedir="${proj.topdir}" >
             <include name="${proj.history}" />
           </fileset>
       </copy>

       <property name="local.plsql.Path" value="${path::combine (proj.Build.path,'OMS\sql_packages\OMS.PLANNED_OUTAGE.pkb') }"/>
       <echo message="${version::plsql( local.plsql.Path, AppBuildNumber.version )}" />

       <property name="local.plsql.Path" value="${path::combine (proj.Build.path,'OMS\sql_packages\OMS.CHED_UTILS.pkb') }"/>
       <echo message="${version::plsql( local.plsql.Path, AppBuildNumber.version )}" />

       <copy todir="${proj.Build.Dir}" verbose="true">
            <fileset basedir="${proj.topdir}">
                <include name="..\Readme.md" />
                <include name="990_Version-pon.oms.sql"/>
            </fileset>
            <filterchain>
                <replacetokens>
                   <token key="ProductVersion" value="V${local.PackageVersion}"/>
                   <token key="ProductDate"    value="${TODAY}"/>
                </replacetokens>
            </filterchain>
        </copy>
        <!-- documentation -->
        <exec program="powershell.exe" verbose="true" workingdir="${proj.Build.Dir}" >
              <arg value='-noProfile' />
              <arg value='-command' />
              <arg value='"&amp;{import-module -verbose md2html; convertto-mdhtml -verbose -recurse }"' />
        </exec>

       <!-- Create a zip only file -->
        <property name="package.zipFname"        value="${path::combine (proj.dist.path,proj.build.name+ '-' + AppBuildNumber.version +'.zip')}" />
        <exec program="${tools.7zip}" workingdir="${proj.Build.Dir}" verbose="true" resultproperty="zip.result" failonerror="true">
          <arg line=' a -tzip "${package.zipFname}"  -ir0@"${package.ListFname}"'  />
        </exec>

    </target>

    <target name="clean" description="Remove all generated files">
        <delete dir="${proj.Dist.Dir}\" failonerror="false" if="${directory::exists(proj.Dist.Dir)}"/>
        <delete dir="${proj.Build.Dir}\" failonerror="false" if="${directory::exists(proj.Build.Dir)}"/>
        <delete verbose="true">
            <fileset>
                <include name="*.log"/>
                <include name="*.html"/>
                <include name="${project::get-name()}.Build.Number"/>
            </fileset>
        </delete>
<!--
        <exec   program="cmd.exe" verbose="true" workingdir="${proj.topdir}\src" failonerror="true">
            <arg line="/C" />
            <arg line="psake.cmd" />
            <arg line="default.ps1" />
            <arg line="clean" />
        </exec>
-->
    </target>


    <target name="set-version" description="Set the version">
        <echo message="${GisOms.release.MajorMinor}" file="${proj.version.file}" append="false" />
        <version buildtype="MonthDay" path="${proj.build.name}.Build.Number" prefix="AppBuildNumber" revisiontype="Automatic" startdate="${GisOms.release.StartDate}" verbose="true"/>
    </target>


    <target name="tag" description="git tag version">
    <loadfile file="${proj.version.file}"     property="AppBuildNumber.version" />
      <!-- Create a tag -->
      <exec program="git.exe" verbose="true"  workingdir="${proj.topdir}"  >
        <arg line= "tag"/>
        <arg line= "V${AppBuildNumber.version}"/>
      </exec>
    </target>


    <target name="get-revision" description="get the git description">
       <exec program="${git.exe}" verbose="true"  workingdir="${proj.topdir}" failonerror="true"  >
          <arg line= "describe" />
          <arg line= "--tag" />
       </exec>
    </target>


    <target name="distribute" description="Copy SDLC deliverables to the GisOms Delivery Server">

        <loadfile file="${proj.version.file}"     property="AppBuildNumber.version" />
        <property name="local.PackageVersion"     value="${AppBuildNumber.version}"/>
        <property name="proj.DeliveryDir" value="${path::combine(core.delivery.gisoms.dir,path::combine(project::get-name(),local.PackageVersion))}" />

        <echo message="proj.DeliveryDir=${proj.DeliveryDir}" />
        <copy todir="${proj.DeliveryDir}" verbose="true">
            <fileset basedir="${proj.Dist.Dir}" >
              <include name="**/*" />
            </fileset>
        </copy>
    </target>


    <target name="show-deliverable" description="show deliverable for single batch job" >
        <loadfile file="${proj.version.file}"     property="AppBuildNumber.version" />
        <property name="local.PackageVersion"     value="${AppBuildNumber.version}"/>
        <property name="proj.DeliveryDir" value="${path::combine(core.delivery.gisoms.dir,path::combine(proj.build.name,local.PackageVersion))}" />
        <exec verbose="true"
            program='explorer.exe'
            workingdir="${proj.topdir}"
            failonerror="false"
            spawn="true"
            commandline='/e,${proj.DeliveryDir}'
        />
    </target>

    <target name="show-secret" description="Shows contents of credential files">
        <exec   program="powershell.exe" verbose="true" workingdir="${proj.topdir}" failonerror="true">
            <arg line="-NoProfile" />
            <arg line="-ExecutionPolicy" />
            <arg line="unrestricted" />
            <arg line="-Command" />
            <arg line="&amp; { .\show-OraSecret.ps1  *.credential}" />
        </exec>
    </target>

    <target name="git-history" description="Extract git history" >
      <property name="proj.history.since" value="2015-05-01" />
      <echo message="
${proj.build.name}
========
" file="${proj.history}" />
      <exec program="${git.exe}" verbose="true"  workingdir="${proj.topdir}"  output="${proj.history}" append="true" >
        <arg line= "log"/>
        <arg line= '--since="${proj.history.since}"'/>
        <arg line= '--pretty=format:"%h - %an, %ai : %s"' />
      </exec>
    </target>

    <target name="git-status" description="Display Git Status">
        <property name="local.status" value="${proj.build.name}.status.log" />
        <delete file="${local.status}" if="${file::exists(local.status)}" />
        <exec program="${git.exe}" verbose="true"  workingdir="${proj.topdir}" failonerror="true" output="${local.status}" >
          <arg line= "status --short --untracked=no  --porcelain"/>
        </exec>
        <if test="${file::exists(local.status) and file::get-length(local.status) > 2 }">
            <loadfile file="${local.status}" property="local.status.result" failonerror="true"/>
            <echo message="${local.status}  ${local.status.result}" />
            <fail message="Modified source files exist. Please commit changes. ${environment::newline()} ${local.status.result} " />
        </if>
    </target>

<!--
    <target name="git_revision" description="git described based revision number of the code" >
        <property name="local.git_revision.log"     value="${proj.build.name}.git_revision.log" />
        <property name="local.git_revision.sql"     value="${proj.build.name}.git_revision.sql" />
        <delete file="${local.git_revision.sql}" if="${file::exists(local.git_revision.sql)}" />
        <delete file="${local.git_revision.log}" if="${file::exists(local.git_revision.log)}" />
        <exec program="${git.exe}" verbose="true"  workingdir="${proj.topdir}" failonerror="true" output="${local.git_revision.log}" >
          <arg line= "describe"/>
        </exec>

        <loadfile file="${local.git_revision.log}" property="local.git_revision" failonerror="true"/>
        <echo message="${local.git_revision.sql}  ${local.git_revision}" />
        <echo message="define REVISION_ID=${local.git_revision}" file="${local.git_revision.sql}" verbose="true"/>
        <echo message="define RELEASE_ID=${proj.build.name}.${AppBuildNumber.version}" file="${local.git_revision.sql}" append="true" verbose="true"/>
    </target>
-->

    <target name="show-props" description="print out props" >
        <script language="C#"  prefix="rgh" >
            <code>
                <![CDATA[
                public static void ScriptMain(Project project) {
                    project.Log(Level.Info, "Properties:");

                    foreach (DictionaryEntry entry in new SortedList(project.Properties)) {
                    if (!entry.Key.ToString().StartsWith("nant."))
                            project.Log(Level.Info, "{0}={1}", entry.Key, entry.Value);
                    }
                }
            ]]></code>
        </script>
    </target>


    <target name="help" description="Help descriptions">
        <echo message="Compiles ${proj.build.name} to a package with versioning"  />
        <echo message='nant -buildfile:"${project::get-buildfile-path()}" -projecthelp'/>
        <exec program="nant">
            <arg line='-buildfile:"${project::get-buildfile-path()}" -projecthelp'/>
        </exec>
    </target>

    <target name="fail">
        <echo message="Notifying you of a failure in the build process."/>
    </target>


    <target name="build-list" description="Generate the list of files to put in the zip deliverable">
        <exec   program="powershell.exe" verbose="true" workingdir="${proj.topdir}" failonerror="true">
            <arg line="-NoProfile" />
            <arg line="-File" />
            <arg line=".\get-build_list.ps1" />
        </exec>
    </target>

    <target name="build-list2" description="Generate the list of files to put in the zip deliverable second method">
        <exec   program="powershell.exe" verbose="true" workingdir="${proj.topdir}" failonerror="true">
            <arg line="-NoProfile" />
            <arg line="-ExecutionPolicy" />
            <arg line="unrestricted" />
            <arg line="-Command" />
            <arg line="&amp; { .\get-build_list.ps1 -verbose}" />
        </exec>
    </target>

</project>

